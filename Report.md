# Отчёт о выполнении задачи "Delivery robot"

- [Отчёт о выполнении задачи "Delivery robot"](#отчёт-о-выполнении-задачи-delivery-robot)
- [Постановка задачи](#постановка-задачи)
- [Известные ограничения, примечания и вводные данные](#известные-ограничения-примечания-и-вводные-данные)
- [Цели и Предположения Безопасности (ЦПБ)](#цели-и-предположения-безопасности-цпб)
- [Архитектура работы системы](#архитектура-работы-системы)
    - [Компоненты](#компоненты)
    - [Алгоритм работы решения](#алгоритм-работы-решения)
    - [Описание Сценариев (последовательности выполнения операций), при которых ЦБ нарушаются](#описание-сценариев-последовательности-выполнения-операций-при-которых-цб-нарушаются)
      - [Негативный сценарий 1. DDOS атака на Communication](#негативный-сценарий-1-ddos-атака-на-communication)
      - [Негативный сценарий 2. Заказ прислан злоумышленником](#негативный-сценарий-2-заказ-прислан-злоумышленником)
      - [Негативный сценарий 3. Некорректный заказ](#негативный-сценарий-3-некорректный-заказ)
      - [Негативный сценарий 4. Атака на Third-party software](#негативный-сценарий-4-атака-на-third-party-software)
      - [Негативный сценарий 5. Взлом Communication](#негативный-сценарий-5-взлом-communication-in)
      - [Негативный сценарий 6. Перезапись данных при повторном заказе](#негативный-сценарий-6-перезапись-данных-при-повторном-заказе)
      - [Негативный сценарий 7. Бездействие компонента](#негативный-сценарий-7-бездействие-компонента)
      - [Негативный сценарий 8. Скрытые поля](#негативный-сценарий-8-скрытые-поля)
      - [Негативный сценарий 9. Отказ модуля gps](#негативный-сценарий-9-отказ-модуля-gps)
      - [Негативный сценарий 10. Ввод пароля не в пункте назначения](#негативный-сценарий-10-ввод-пароля-не-в-пункте-назначения)
      - [Негативный сценарий 11. Перебор паролей](#негативный-сценарий-11-перебор-паролей)
      - [Негативный сценарий 12. Получение неверных данных от компонента](#негативный-сценарий-12-получение-неверных-данных-от-компонента)
      - [Негативный сценарий 13. Потеря чувствительной информации](#негативный-сценарий-13-потеря-чувствительной-информации)
      - [Негативный сценарий 14. Компонент притворяется другим](#негативный-сценарий-14-компонент-притворяется-другим)
      - [Негативный сценарий 15. Потеря заказа при получении](#негативный-сценарий-15-потеря-заказа-при-получении)
      - [Негативный сценарий 16. Внутренний DOS](#негативный-сценарий-16-внутренний-dos)
      - [Негативный сценарий 17. Атака на персональные данные](#негативный-сценарий-17-атака-на-персональные-данные)
      - [Негативный сценарий 18. Несохранение снимка камеры](#негативный-сценарий-18-несохранение-снимка-камеры)
      - [Негативный сценарий 19. Атака на внутрисистемное время](#негативный-сценарий-19-атака-на-внутрисистемное-время)
      - [Негативный сценарий 20. Чтение чужих сообщений](#негативный-сценарий-20-чтение-чужих-сообщений)
      - [Негативный сценарий 21. Невозможность записать лог](#негативный-сценарий-21-невозможность-записать-лог)
      - [Негативный сценарий 22. Потеря лога](#негативный-сценарий-22-потеря-лога)
      - [Сводная таблица негативных сценариев](#сводная-таблица-негативных-сценариев)
 - [Указание "доверенных компонент" на архитектурной диаграмме.](#указание-доверенных-компонент-на-архитектурной-диаграмме)
 - [Известные проблемы реализации](#известные-проблемы-реализации)
 - [Политики безопасности](#политики-безопасности)
 - [Запуск приложения и тестов](#запуск-приложения-и-тестов)
    - [Запуск приложения](#запуск-приложения)
    - [Запуск тестов](#запуск-тестов)


## Постановка задачи
Необходимо создать программное обеспечение (далее – ПО) для робота-доставщика (далее – робот), с помощью которого можно обеспечить безопасную доставку и выдачу заказа (верифицированному) клиенту только в указанной точке, возвращение на базу и завершение работы.

## Известные ограничения, примечания и вводные данные:
**По условию:**
1. По условиям организаторов должна использоваться микросервисная архитектура и шина обмена сообщениями для реализации асинхронной работы сервисов.
2. Между собой сервисы общаются через шину сообщений (message bus), а всё снаружи принимают в виде REST запросов.
3. Физическая надёжность аппаратуры не учитывается.
4. Заказ не имеет массы и объёма.
5. Графический интерфейс для взаимодействия с пользователем не требуется, достаточно примеров REST запросов.
6. Приборная точность позиционирования достаточна для выполнения задания доставки.
7. Механизм безопасной передачи пароля клиенту не требуется реализовывать в рамках работы -> клиент **знает** правильный пароль от заказа.
8. Задача считается завершенной только по прибытии обратно на базу.

**Добавленные в ходе анализа:**

9. Движение осуществляется итерационно по прямой.
10. База имеет фиксированные координаты (x0 = 0, y0 = 0).
11. Геолокация: позиционирование на местности по двум системам - GPS (спутниковая навигационная система) и ИНС (инерциальная навигационная система).
12. Автономность: робот должен корректно продолжать работу в т.ч. при потере связи с сервером или GPS вплоть до накопления некоторой критической ошибки ИНС (для упрощения был взят отрезок в половину расстояния до следующей запланированной точки движения), а иначе попытка возвращения на базу.
13. Х1 и Y1 - адрес доставки заказа.
14. По умолчанию батареи робота хватает на доставку в квадрате с противолежащими вершинами (-100;-100) и (100;100) (т.е. заказы с координатами выходящими за рамки этого квадрата должны отсекаться системой безопасности робота).  
15. Контроль: уровень заряда, распознавание препятствий, поломка. В случае критических проблем дрон должен вернуться на базу.


### Цели и Предположения Безопасности (ЦПБ)
**Бизнес-цель:**
  - Доставка и выдача верифицированному клиенту заказа в заданной точке.

**Цели безопасности:**
1. Обеспечение сохранности груза до момента передачи авторизованному клиенту.
2. Получение задания только от корпоративного сервера.
3. В случае многократных попыток неавторизованного доступа заблокировать груз и вернуться на склад.

**Добавленные:**
4. Осуществлять проверку пинкода только по достижению указанной в заказе точки.
5. В случае потери связи с GPS продолжать движение по ИНС, если сигнал не вернется в течении пути к следующему отрезку - возвращаться на базу.
6. Базовая защита REST-коммуникаций (шифрование, заголовки)
7. Принимать только валидные заказы (т.е. те, которые робот сможет выполнить: содержащие координаты, удовлетворяющие их параметрам из вводных данных, пин-код).
8. Сохранение "чувствительной" информации роботом (т.е. любой, не предусмотренной к выходу из системы в этой документации - например, входных данных заказа или фотографии клиента).
9. Аутентификация компонентов (т.е. невозможность одного компонента представиться другим).
10. Необходимость хранить лог работы системы (т.е. сообщения, выдаваемые монитором безопасности).
11. Необходимо сохранять снимок человека при выдаче заказа.

**Предположения безопасности:**

Целями безопасности робота не являются:

1. Защита от атак с использованием физического доступа.

В силу невозможности своевременной реализации предполагаем также:

2. Компонент communication и gps обращается только к доверенному списку адресов, для чего используется доверенный Firewall на уровне системы, который управляя аппаратными компонентами блокирует связь с адресами не из white-list и т.д.
3. Между компонентами fleet и center реализовано e2e шифрование сообщений.
4. Все компоненты робота связываются ТОЛЬКО через monitor и не могут связываться напрямую друг с другом в т.ч. на аппаратном уровне.

## Архитектура работы системы
![DFD](./pics/dfd.png?raw=true "Архитектура")

### Компоненты

| Название | Назначение | Комментарий |
|----|----|----|
|*Central Control Unit (central)* | Принимает в работу заказ, сохраняет требуемую точку доставки и пинкод, запускает расчет и старт движения. При получении сообщения о достижении точки назначения проверяет по координатам соответствие, разрешает считывать пинкод. Проверяет пинкод ограниченное количество раз, по закрытии или при ошибке пароля более 3 раз запускает расчет и движение обратно. По достижении пункта назначения инициирует отправку сообщения со статусом заказа через Communication на Fleet. Отслеживает прерывание сигнала gps. Отслеживает ошибки позиционирования, верит ИНС. |  |
|*Motion control (motion)* | Осуществляет движение по полученным направлению и скорости в течении заданного расстояния с учетом аппаратных ограничений. | |
|*Client (client)* | Взаимодействует с роботом через API. Использует для авторизации уже известный ему уникальный PIN код. | |
|*Fleet management service (fleet)*  | Абстрактный сотрудник выдает заказы роботу при помощи файла request.rest, получая на REST интерфейс уведомления о принятии заказа к выполнению и о результате доставки (т.е. в т.ч. и о неудачном возвращении робота на базу). | |
|*Позиционирование (position)* | Осуществляет функции расчета параметров движения. Строит аварийный маршрут возвращения на базу. Выдаёт текущие координаты (x, y).  | ИНС осталась в составе position, а gps вынесена в отдельную сущность в целях декомпозиции. |
|*GPS (gps)* | Осуществляет связь со спутником, выдает текущие координаты робота. Иногда отваливается - потеря сигнала происходит :) | |
|*Communication in (communication_in)* | Разворачивает REST API для приема заказа, передачи его далее по шине, т.е. отвечает за прием сообщений. | |
|*Communication out (communication_out)* | Разворачивает REST API для передачи на fleet сообщений подтверждения и результата доставки, т.е отвечает за передачу сообщений. | |
|*HMI (hmi)* | Разворачивает REST API для приема заказа и передачи его далее по шине. Поскольку подразумевается автономное функционирование робота, то данный элемент считаем аппаратной составляющей со всеми вытекающими последствиями для безопасности.  | |
|*Sensors (sensors)* | Открывают замки при команде от монитора безопасности, через 5 секунд закрывает, отправляя об этом сообщение. | Camera - вынесена отдельно в целях декомпозиции |
|*Camera (camera)* | При вводе пинкода должна осуществлять съемку человека, что он забрал заказ. | |
|*Security monitor*<br>(монитор безопасности) | Авторизует операцию, если она удовлетворяет заданным правилам или блокирует её в противном случае. Выполняет иные функции обеспечения информационной безопасности, хранит лог работы системы. | |
|*Message bus* | Шина сообщений и брокер - сервис передачи сообщений от источника получателям | kafka+zookeeper | |


### Алгоритм работы решения

![Sequence diagram](./pics/sd.png?raw=true "Диаграмма вызовов")

---
Message bus и Security Monitor на диаграммах опущены для лучшей читаемости и уменьшения размера картинки. КАЖДОЕ сообщение внутри системы проходит через monitor, который, исходя из политик, принимает решение пропустить его или нет.
---

### Описание Сценариев (последовательности выполнения операций), при которых ЦБ нарушаются

Для начала произведем анализ системы.

По условию задания, компоненты **Message Bus** и **Security Monitor** доверенные, что вполне логично - они являются основополагающими элементами взаимодействия системы.

Рассмотрим теперь **Central Control Unit** - он является главным логическим узлом всей системы, следовательно также будет являться доверенным. Остается вопрос - можно ли вынести из него некоторый функционал, чтобы уменьшить количество кода, требующего проверки. Представляется, что на данный момент такого функционала нет.

Сугубо теоретически, возможно представить вынос основных функций **central** в **monitor**, однако это фактически все равно не приводит к уменьшению проверяемой кодовой базы в два раза, а кроме того нарушается логика разделения компонентов. Кроме того, укрупнение компонентов так же видится негативной практикой.

В результате авторской оценки, блок **position** был усложнен до более реальной схемы с двумя независимыми блоками исчисления координат - **GPS** (вынесен отдельно) и **ИНС (Microelectromechanical systems (mems))** (остался в составе **position**), что позволяет закрыть вопрос с однозначной оценкой точного местоположения и таким образом закрывает требование ЦБ о выдаче заказа только в заданной точке.

Т.к. реальное движение подразумевает итерационность, то единый акт движения по прямой, предусмотренный изначальным ТЗ, также был усложнен и разбит на некоторое случайное число отрезков. 

В результате, во-первых, конечную точку маршрута знает только **center**, ну и **communication_in**, т.к. он промежуточный (есть нюансы - смотри рассуждения о шифровании в соответсвующем модуле), а во-вторых, в рамках каждого короткого отрезка становится возможно отслеживать координаты одновременно по данным ИНС (**position**) и GPS. 

Поскольку резервное возвращение осуществляется блоком ИНС, а наши координаты важны для ЦБ, то ИНС будет включаться в состав **position** и будет доверенным.
Тогда если результаты работы gps и ИНС не совпадут, то можно будет доверять ИНС. 

Отсюда следует, что при отказе gps, можно еще некоторое время двигаться вперед по ИНС, а если сигнал не вернется, то вернуться на базу. В целях упрощения данного механизма, было принято решение, что робот сможет доехать лишь до середины следующей запланированной итерации при отказе gps, а если там сигнал не вернется, то вернуться на базу.

Отказ gps осуществляется случайным вызовом соответствующей функции, следовательно в работе может произойти в любой момент.

---
Внимание! Добавление новых (не указанных в изначальном ТЗ) аппаратных компонентов (в данном случае введение сущностей gps/mems) со своей спецификой является нерекомендуемым направлением авторского (экспертного) анализа и не оптимальным способом решения найденной проблемы. Вероятно, это приведет к значительному увеличению требуемого на реализацию времени, хотя и концептуально не противоречит истине. Таким образом, более эффективным представляется поиск программного способа решения задачи.
---

Идем дальше. Если будет взломан компонент **motion**, то это приведет к нарушению бизнес-функции робота, но заявленные ЦБ будут выполняться.

Поскольку автор исходит из того, что **HMI** - интерфейс на роботе, недоступный извне через REST (т.е. не так, как это реализовано сейчас для удобства), то взлом **HMI** приведет максимум к нарушению бизнес-функции робота, но ЦБ будут соблюдаться. Возможно, что злоумышленник постфактум сможет узнать пароль, введенный клиентом (в комбинации с другими взломами), но т.к. **HMI** активируется только при достижении заявленной точки, то это не является проблемой. Впрочем, могут быть вопросы к реверсу генератора случайных паролей на сервере при большой выборке данных, но это уже выходит за рамки работы.

Самой серьезной проблемой представляется взлом замков **Sensors**, что позволит злоумышленнику просто их открыть. Таким образом, компонент следует добавить в доверенные компоненты. По этой причине, блок **Camera** был вынесен отдельно - чтобы не проверять его, поскольку он не оказывает влияние на ЦБ и на основную функцию.

Проблема могла бы быть, если взломан **Communication_in** – поскольку в реализации заказ один, то получение нового заказа при выполнении старого перезаписало бы требуемый пинкод и адрес, и позволило бы злоумышленнику получать чужой заказ. Для противодействия этого была реализована блокировка приема новых сообщений через политики безопасности до возвращения робота на базу.

Кроме того, у робота фактически есть три внешние точки доступа – через **GPS**, **Communication_out** и **Communication_in**, который, к тому же использует Flask. Следовательно – эти компоненты следует тщательно досматривать – на политики проверки сообщений от них навесить жесткие ограничения по валидации содержимого: длина, значения, отрубать их при возможности, а также уделить особое внимание настройке сетевых параметров так, чтобы связаться с ними можно было только от заранее указанного сервера с авторизацией и т.д. 

Кроме того, в случае **Communication_in** имеется смысл, например, в реализации алгоритма Диффи-Хеллмана, т.е. обмена открытым-закрытым ключем для дешифровки сообщения. Более того, в действительности это шифрование должно быть между fleet и center, что позволит сделать communication_in недоверенным, но не позволит ему подменить заказ или переслать его злоумышленнику, т.к. функционал отправки сообщений вынесен в отдельный блок communication_out. Впрочем, реализация самого шифрования выходит за рамки возможностей автора в установленные сроки, поэтому этот пункт вынесен в предположения безопасности.

Может ли комбинация взломов компонентов нарушить ЦБ? Понятно, что в случае доверенных компонент - да. Если же говорить о недоверенных, т.е. gps, hmi, motion, communication_in, camera - ни один из них не связан напрямую с другим, а следовательно их некорректное взаимодействие практически невозможно координировать между собой. Автор считает, что наиболее вероятная среди всех комбинаций - передача "лишней информации" с телом корректного ответа компонента и дальнейшая его передача через communication_in, которая где-то по пути перехватывается злоумышленником. Это частично решено путем проверки передаваемой "наружу" информации в monitor - т.е. при помощи политик.

Таким образом, становится возможным сформулировать список доверенных компонентов (см. соответствующий раздел) и рассмотреть возможные сценарии нарушения ЦБ.

Автором были определены 22 наиболее вероятных сценариев атаки на систему:
1. DDOS атака на Communication_in;
2. Заказ прислан злоумышленником, а не сервером, сюда же MITM;
3. Взлом сервера и выдача им некорректного заказа - например, который находится слишком далеко.
4. Атака через Third-party software (например, Flask в communication);
5. Взлом Communication_in как открытой точки доступа в сеть;
6. Перезапись "чувствительных" данных при повторном заказе;
7. Бездействие какого-либо компонента;
8. Скрытые поля и их использование для code injections (на любой входной точке в систему, т.к. для надежности посчитаем, что любая внешняя защита может быть скомпрометированной);
9. Отказ модуля **gps** (и физический (потеря сигнала) и ложь в координатах (была приравнена в коде к отказу))
10. Ввод паролей не в пункте назначения;
11. Перебор паролей;
12. Получение неверных данных (например, координат) от компонента;
13. Вынос "чувствительной" информации (например, фото клиента) из системы при помощи комбинации взломанных компонентов; 
14. Компонент притворяется другим. 
15. Отправка копии заказа злоумышленнику еще при получении.
16. Внутренний DOS от взломанного компонента.
17. Попытка кражи персональных данных с камеры.
18. Несохранение снимка камеры.
19. Атака через GPS на внутрисистемное время. 
20. Чтение чужих сообщений из общей очереди.
21. Невозможность записать лог работы системы.
22. Потеря лога работы системы.

Здесь необходимо сделать ремарку, что концепция сохранения локальных копий используемых библиотек и проверки только поступающих обновлений подразумевает идею о том, что в условиях разработанной архитектуры простая эксплуатация уже существующей уязвимости в компоненте не позволит выйти за его пределы, т.к. если это и возможно, то потребуется доступ на уровне RCE, т.е. злоумышленнику все равно придется как-то доставлять код во взломанный компонент, поэтому сделан специальный **communication** в качестве буфера перед системой и **monitor**, который позволяет осуществлять валидацию.

В результате, в текущей реализации системы наиболее вероятным представляется невыполнение бизнес-функции в результате атаки на робота при соблюдении всех заявленных ЦБ.

![Негативные сценарии](./pics/sd_risks.png?raw=true "Негативные сценарии")

### Негативный сценарий 1. DDOS атака на Communication
![Негативные сценарии](./pics/sd_1.png?raw=true "")

Нарушается цель безопасности №6 и бизнес-функция.
Компенсируется отключением компонента Communication до необходимости отправить сообщение со статусом операции (опционально, при получении какого-то количества "неправильных" сообщений), связью только с абонентами из white-list и т.п.

### Негативный сценарий 2. Заказ прислан злоумышленником
![Негативные сценарии](./pics/sd_2.png?raw=true "")

Нарушается цель безопасности №1,2.
Компенсируется использованием аутентификацией сервера, например, реализацией алгоритма Диффи-Халлмана и связью только с доверенным списком адресов.

### Негативный сценарий 3. Некорректный заказ
![Негативные сценарии](./pics/sd_3.png?raw=true "")

Нарушается цель безопасности №7.
Компенсируется валидацией заказа - как далеко находится точка, хватит ли до нее заряда и т.д.

### Негативный сценарий 4. Атака на Third-party software
![Негативные сценарии](./pics/sd_4.png?raw=true "")

Нарушается цель безопасности (в теории) №1,2,4,5,6.
Компенсируется проверкой входящих в доверенные компоненты частей, использованием локальных и/или проверенных копий библиотек, проверкой обновлений.

### Негативный сценарий 5. Взлом Communication_in
![Негативные сценарии](./pics/sd_5.png?raw=true "")

Нарушается цель безопасности №2,6.
Компенсируется настройкой доступа только с доверенного списка адресов, с четким содержимым входящих сообщений и т.п. безопасностью.

### Негативный сценарий 6. Перезапись данных при повторном заказе
![Негативные сценарии](./pics/sd_6.png?raw=true "")

Нарушается цель безопасности №1,2.
Компенсируется блокировкой возможности повторного заказа.

### Негативный сценарий 7. Бездействие компонента
![Негативные сценарии](./pics/sd_7.png?raw=true "")

Нарушается бизнес-функция, возможно цель безопасности №1,11.
Полноценная компенсация представляется невозможной. Возможно некий компонент, который будет обнаруживать "падение" компонента и перезапускать его. В идеале, можно даже представить, что он будет брать на себя его роль. А ля, есть сохраненный код компонентов, при падении одного из них и невозможности перезапуска, данный компонент-двойник берет нужный исходник и загружается в работу.

В данный момент, реализован механизм объединения нескольких строго последовательных действий в "цепочки" в мониторе, т.е. может быть обнаружено отсутсвие ответа в течении заданного времени и осуществлено соответсвующее реагирование в зависимости от компонента: от соообщения об ошибке до отправки на базу. Так же см. сценарий №16.

### Негативный сценарий 8. Скрытые поля
![Негативные сценарии](./pics/sd_8.png?raw=true "")

В данном случае не имеет значения, откуда пришли скрытые поля, от fleet или от хакера, т.к. это рассматривается в других сценариях атаки. Здесь важен факт попадания "лишних данных" в систему. 
Нарушается цель безопасности №1,7.
Возможно влияние на ЦБ №10,11.
Компенсируется валидацией входящих (и опционально исходящих) сообщений, экранированием полей.

### Негативный сценарий 9. Отказ модуля gps
![Негативные сценарии](./pics/sd_9.png?raw=true "")

Нарушается цель безопасности №5.
Компенсируется еще на уровне логики работы системы.

### Негативный сценарий 10. Ввод пароля не в пункте назначения
![Негативные сценарии](./pics/sd_10.png?raw=true "")

Нарушается цель безопасности №4.
Компенсируется активацией компонента доверенным компонентом при достижении точки, что зафиксировано другим доверенным компонентом.

### Негативный сценарий 11. Перебор паролей
![Негативные сценарии](./pics/sd_11.png?raw=true "")

Нарушается цель безопасности №3.
Компенсируется ограничением количества попыток.

### Негативный сценарий 12. Получение неверных данных от компонента
![Негативные сценарии](./pics/sd_12.png?raw=true "")

Нарушается цель безопасности №1,2,3,4.
Компенсируется на уровне архитектуры системы.

### Негативный сценарий 13. Потеря чувствительной информации
![Негативные сценарии](./pics/sd_13.png?raw=true "")

Здесь следует сделать ремарку, что взламывается необязательно central, смысл в том, что лишняя информация к сообщению может быть приложена еще на более ранних этапах каким-либо взломанным (или плохо придуманным изначально) компонентом и затем долгое время гулять по системе. Но отправляется в конечном итоге она все равно из cental в communication_out. Поэтому рисунок такой, какой он есть.
Нарушается цель безопасности №8.
Компенсируется валидацией исходящих сообщений.

### Негативный сценарий 14. Компонент притворяется другим
![Негативные сценарии](./pics/sd_14.png?raw=true "")

Нарушается цель безопасности №9, возможно влияние на ЦБ№1-8.
Компенсируется на уровне архитектуры системы выдачей уникальных имен компонентам монитором (используются только для отправки сообщений, в мониторе меняются на общеизвестные имена), в результате чего никакой компонент не знает, как завут другой -> не может представиться им.

### Негативный сценарий 15. Потеря заказа при получении
![Негативные сценарии](./pics/sd_15.png?raw=true "")

Нарушается цель безопасности №6,8.
Компенсируется на уровне архитектуры системы разделением приемника и передатчика -> нет прямой связи входящих и исходящих сообщений.

### Негативный сценарий 16. Внутренний DOS
![Негативные сценарии](./pics/sd_16.png?raw=true "")

Здесь подразумевается несвоевременная отправка сообщений компонентом.

Нарушается цель безопасности №1.
Компенсируется механизмом ожидания ответа на сообщение в monitor. Безусловно, не с каждым сообщением такое возможно, но некоторая их часть может быть объединена в цепочки последовательностей, что позволяет ставить "ожидание" появления конкретного типа сообщения. В случае, если же оно появилось неожиданно - его требуется откинуть. 

### Негативный сценарий 17. Атака на персональные данные
![Негативные сценарии](./pics/sd_17.png?raw=true "")

Нарушается цель безопасности №8.
Компенсируется на уровне архитектуры системы, см. сценарий 13.

### Негативный сценарий 18. Несохранение снимка камеры
![Негативные сценарии](./pics/sd_18.png?raw=true "")

Нарушается цель безопасности №11.
Компенсируется проверкой наличия фото перед открытием замков. В случае отсутсвия - отмена открытия.

### Негативный сценарий 19. Атака на внутрисистемное время
![Негативные сценарии](./pics/sd_19.png?raw=true "")

Нарушается цель безопасности №1.
Компенсируется на уровне архитектуры системы.

### Негативный сценарий 20. Чтение чужих сообщений
![Негативные сценарии](./pics/sd_20.png?raw=true "")

Нарушается цель безопасности №9.
Компенсируется на уровне архитектуры системы авторизацией компонента в менеджере сообщений. На данный момент не реализовано -> вынесено в предположения.

### Негативный сценарий 21. Невозможность записать лог
![Негативные сценарии](./pics/sd_21.png?raw=true "")

Нарушается цель безопасности №10.
Обрабатывается - робот возвращается на базу.

### Негативный сценарий 22. Потеря лога
![Негативные сценарии](./pics/sd_22.png?raw=true "")

Нарушается цель безопасности №10.
Компенсируется на уровне архитектуры системы организацией доступа к памяти. При заполнении памяти должна осуществляться сигнализация менеджеру. При ошибке - возвращение на базу. Кроме того, здесь стоит рассмотреть механизм минимизации размера лога, но он выходит за рамки работы.




#### Сводная таблица негативных сценариев*

|№  | Название | Скомпрометированная/Атакованная часть системы | Нарушенная цель безопасности |
|----|----|----|----|
|1 | DDOS атака на Communication | Communication_in | 6 |
|2 | Заказ прислан злоумышленником | Communication_in, Central | 1,2 |
|3 | Некорректный заказ | Central | 7 |
|4 | Атака на Third-party software | Any untrusted | 1,2,4,5,6 |
|5 | Взлом Communication_in | Communication_in | 2,6 |
|6 | Перезапись данных при повторном заказе | Communication_in, Central | 1,2 |
|7 | Бездействие компонента | Any untrusted | - |
|8 | Скрытые поля | Communication_in, Central | 1,7 |
|9 | Отказ модуля gps | Position, GPS | 5 |
|10 | Ввод пароля не в пункте назначения | HMI | 4 |
|11 | Перебор паролей | Central | 3 |
|12 | Получение неверных данных от компонента | Central | 1,2,3,4 |
|13 | Потеря чувствительной информации | Communication_out | 8 |
|14 | Компонент притворяется другим | Any untrusted | 9 |
|15 | Потеря заказа при получении | Communication_in | 6,8 |
|16 | Внутренний DOS | Any untrusted | 1 |
|17 | Атака на персональные данные | Camera | 8, 11 |
|18 | Несохранение снимка камеры | Camera | 11 |
|19 | Атака на внутрисистемное время | GPS | 1 |
|20 | Чтение чужих сообщений | Any untrusted | 9 |
|21 | Невозможность записать лог | Monitor | 10 |
|22 | Потеря лога | Monitor | 10 |


### Указание "доверенных компонент" на архитектурной диаграмме.

В предыдущем разделе были рассмотрены возможные сценарии нарушения ЦБ, по результатам чего были определены доверенные компоненты - **monitor**, **message bus**, **position**, **central**, **communication_out** и **sensors**, по причине того, что шина обмена сообщений и монитор безопасности являются общесистемными, а также мы хотим доверять результатам работы блока управления роботом, его модулю позиционирования, устройству передачи информации по сети и замкам хранилища заказа.

![DFD-TCB](./pics/dfd_trusted.png?raw=true "Доверенные компоненты")

Теоретически, шину обмена сообщениями можно сделать недоверенным компонентом, но тогда необходимо будет реализовать механизм верификации сообщений. Например, можно использовать технологию типа blockchain.
Цена этого изменения - усложнение обмена сообщениями, дополнительные накладные расходы на верификацию, снижение производительности системы, возможно также возникновение нестабильности и различные ситуации гонок.

### Известные проблемы реализации
- Не реализованы тесты для части негативных сценариев, см. таблицу в соответствующем разделе.
- Не осуществлена комплексная проверка, что будет, если ЛЮБОЙ НЕДОВЕРЕННЫЙ компонент будет присылать одновременно множественные разные ответы и т.д. По предварительным результатам, при подавляющем большинстве сценариев, корректность работы нарушена не будет, но верификация тестового набора произведена не была, следовательно утверждать это на данный момент нельзя.

### Политики безопасности
```python {lineNo:true}
from multiprocessing.resource_sharer import stop
import os
import threading
import time
from uuid import uuid4
from producer import proceed_to_deliver


ordering = False
UNIC_NAME_MOTION = uuid4().__str__()
#etc.

motion_start_request = True
#etc.


def set_names(id):
    motion_details = {
        "id": id,
        "operation": "set_name",
        "deliver_to": "motion",
        "source": "",
        "name": UNIC_NAME_MOTION
    }
    proceed_to_deliver(id, motion_details)
   #etc.


def awaiting_response(id, operation, dst, start_time):
    global motion_start_request
    #etc.
    if  operation == "confirmation":
        while not confirmation_response:
            time.sleep(0.2)
            now = time.time()
            if (now - start_time) > 10:
                print(f"[confirmation] timeout exception!")
                break
    elif  operation == "count_direction" and dst == "position":
        while not count_direction_response:
            time.sleep(0.2)
            now = time.time()
            if (now - start_time) > 10:
                print(f"[count_direction] timeout exception!")
                break
   #etc.
        
        


def check_operation(id, details):
    global ordering
    global UNIC_NAME_MOTION
    #etc.
    global motion_start_request
    #etc.
    authorized = False
    src = details['source']
    dst = details['deliver_to']
    operation = details['operation']
    
    if  src == 'communication_in' and dst == 'central' and operation == 'ordering':
        if type(details['pincode']) == str \
                and type(details['x1']) == int and type(details['y1']) == int \
                and abs(details['x1']) <= 200 and abs(details['y1']) <= 200  and len(details) == 7 :
            if not ordering:
                authorized = True
                ordering = True
                
                set_names(id)
                
                start_time = time.time()
                confirmation_response = False
                count_direction_request = False
                threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()

            else:
                details['source'] = UNIC_NAME_MONITOR
                details['operation'] = 'reordering'
                details['deliver_to'] = 'monitor'
                proceed_to_deliver(id, details)
        else:
            details['source'] = UNIC_NAME_MONITOR
            details['operation'] = 'invalid_order'
            details['deliver_to'] = 'monitor'
            proceed_to_deliver(id, details)
    
    if src == UNIC_NAME_CENTRAL and dst == 'communication_out' \
        and operation == 'confirmation':
        #antiddos
        details['source'] = 'central'
        if not confirmation_response:
            confirmation_response = True
            authorized = True    
    if src == UNIC_NAME_CENTRAL and dst == 'position' \
        and operation == 'count_direction':
        details['source'] = 'central'
        authorized = True
        start_time = time.time()
        count_direction_response = False
        threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()    

    if src == UNIC_NAME_POSITION and dst == 'central' \
        and operation == 'count_direction':
        
        if not count_direction_response:
            count_direction_response = True   
            details['source'] = 'position'
            authorized = True 
            start_time = time.time()
            motion_start_request = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()

    if src == UNIC_NAME_CENTRAL and dst == 'motion' \
        and operation == 'motion_start':    
        if not motion_start_request:
            motion_start_request = True
            details['source'] = 'central'
            authorized = True
            start_time = time.time()
            stop_request = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()    

    if src == UNIC_NAME_MOTION and dst == 'position' \
        and operation == 'motion_start':
        #and details['verified'] is True:
        details['source'] = 'motion'
        authorized = True    
    
    if src == UNIC_NAME_MOTION and dst == 'position' \
        and operation == 'stop':
        if not stop_request:
            stop_request = True
            details['source'] = 'motion'
            authorized = True
            start_time = time.time()
            stop_response = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()    
    if src == UNIC_NAME_POSITION and dst == 'central' \
        and operation == 'stop':
        if not stop_response:
            stop_response = True
            details['source'] = 'position'
            authorized = True
            start_time = time.time()
            gps_request = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()


    # here should understand that when hmi would be hardware, UNIC_NAME_HMI will be able to be, 
    # but now there are some software troubles to do it
    if src == 'hmi' and dst == 'central' \
        and operation == 'pincoding':
        if not activate_request:
            activate_request = True
            authorized = True
            start_time = time.time()
            pincoding_request = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()    
    if src == UNIC_NAME_CENTRAL and dst == 'sensors' \
        and operation == 'lock_opening':
        details['source'] = 'central'
        if not pincoding_request:
            try:
                files = os.listdir("/storage")
                #print (files)
                files = [file for file in files if "Picture_" in file]
                #print (files)
                file = max(files, key=lambda i: os.stat("/storage/"+i).st_mtime)
                #print(file)
                if (time.time() - os.stat("/storage/"+file).st_mtime) < 30:
                    print("Picture was founded!")
                    pincoding_request = True
                    authorized = True
                    lock_closing_request = False
                    start_time = time.time()
                    threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()
                else:
                    details['deliver_to'] = 'cental'
                    details['operation'] = 'lock_closing'
                    details['source'] = 'sensors'
                    proceed_to_deliver(id, details)   
            except Exception as e:
                print(f"[error] failed to find picture: {e}")
            
    if  src == UNIC_NAME_SENSORS and dst == 'central'\
        and operation == 'lock_closing':
        details['source'] = 'sensors'
        if not lock_closing_request:
            lock_closing_request = True
            authorized = True
            start_time = time.time()
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()   
    if  src == UNIC_NAME_CENTRAL and dst == 'communication_out'\
        and operation == 'operation_status' and len(details) == 5:
        details['source'] = 'central'
        authorized = True
        ordering = False
    if  src == UNIC_NAME_CENTRAL and dst == 'camera'\
        and operation == 'activate':
        details['source'] = 'central'
        authorized = True
        activate_request = False
        start_time = time.time()
        threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()   
    if  src == UNIC_NAME_CENTRAL and dst == 'camera'\
        and operation == 'deactivate':
        if not lock_closing_request:
            lock_closing_request = True
            details['source'] = 'central'
            authorized = True
        if not pincoding_request:
            pincoding_request = True
            details['source'] = 'central'
            authorized = True

    if  src == UNIC_NAME_MONITOR and dst == 'monitor':
        details['source'] = 'monitor'
        authorized = True
    if  src == UNIC_NAME_CENTRAL and dst == 'monitor':
        details['source'] = 'central'
        authorized = True

    
    if  src == UNIC_NAME_CENTRAL and dst == 'gps'\
        and operation == 'where_am_i':
        if not gps_request:
            gps_request = True
            details['source'] = 'central'
            authorized = True
            start_time = time.time()
            gps_response = False
            threading.Thread(target=lambda: awaiting_response(id, operation, dst, start_time)).start()
    #simple checking length of messages
    if  src == UNIC_NAME_GPS and dst == 'central'\
        and operation == 'gps' and len(details) == 6:
        if not gps_response:
            gps_response = True
            details['source'] = 'gps'
            authorized = True
    if  src == UNIC_NAME_GPS and dst == 'central'\
        and operation == 'gps_error' and len(details) == 4:
        if not gps_response:
            gps_response = True
            details['source'] = 'gps'
            authorized = True
    if  src == UNIC_NAME_POSITION and dst == 'gps'\
        and operation == 'nonexistent':
        details['source'] = 'position'
        authorized = True
        

    return authorized
```

## Запуск приложения и тестов

### Запуск приложения

см. [инструкцию по запуску](../../README.md)

### Запуск тестов

_Предполагается, что в ходе подготовки рабочего места все системные пакеты были установлены._

Запуск примера: открыть окно терминала в Visual Studio code, в папке delivery-robot с исходным кодом выполнить команду:

**make run**
или **docker-compose up -d**

Примечание: контейнер broker имеет свойство падать при запуске, поэтому спустя секунд 15 после запуска команды **make run** имеет смысл проверить, находится ли он в состоянии UP и в случае чего повторно его запустить.

Примечание 2: сервисам требуется некоторое время для начала обработки входящих сообщений от kafka, поэтому перед переходом к тестам следует сделать паузу не менее минуты.

Запуск тестов:
**make test**
или **pytest**

Будут выполнены 7 тестов, 1 общий на корректность работы, 6 на безопасность, ожидаемое время выполнения зависит от входных (x,y) и в среднем составляет ~ 6-8 минут.

Ожидаемый результат выглядит следующим образом:

![test](./pics/test_result.png?raw=true "Тестирование")

Можно заметить, что первая серия тестов прошла успешно, а во второй тест функциональности провален. Это обусловлено тем, что gps в случайные моменты времени отказывается работать (как и было задумано изначально автором), а потому тесты, действительно, могут не проходить. В таком случае нужно запустить их еще раз. Т.к. отказы случайные, то поведение тестового сценария повторяться не должно.

Кроме того стоит обратить внимание на таблицу покрытия тестами сценариев атаки:

| Название | Статус | Комментарий |
|----|----|----|
|ddos_communication|готов|-|
|unauthorized_order|готов|-|
|incorrect_order|готов|-|
|third_party_attack|-|Не может быть реализовано в тесте?|
|communication_hacking|-|Не может быть реализовано в тесте?|
|repeating_order|готов|-|
|inaction|-|TBD|
|hidden_fields|см. валидацию полей в политиках|Не может быть реализовано, кроме как вручную, т.к. частично покрывается еще в incorrect_order + подразумевается поставка команд скомпрометированному компоненту |
|gps_broken|см. реализацию|Это возможно иногда наблюдать вживую, если смотреть лог работы программы, а также, есть возможность руками поменять в файле gps/consumer.py строку 27, увеличив вероятность возникновения ошибки и посмотреть на результат|
|password_not_in_destination_point|готов|-|
|bruteforce|готов|-|
|component_lie|см. реализацию|Возможно наблюдать, если руками поменять в файле gps/consumer.py строки 33 и 34, вставив туда заведомо неверные координаты|
|sensitive_output|см. валидацию полей в политиках|Возможно наблюдать, если зайти в central/consumer.py, найти блок отправки операции operation_status и добавить туда какое-нибудь свое поле - тогда при выполнении в логах monitor должно будет отобразиться сообщение о блокировке операции по причине несоответсвия полей.|
|name_substitution|-|Не может быть реализовано в тесте?|
|loss_upon_receipt|-|Не может быть реализовано в тесте?|
|internal_dos|TBD|-|
|personal_data_attack|-|Не может быть реализовано в тесте? См. sensitive_output|
|image_appearance|TBD|-|
|system_time_attack|-|Не может быть реализовано в тесте?|
|unauthorized_reading|TBD|-|
|log unavailability|TBD|-|
|log_losing|TBD|-|


